// Advanced Message Handler with Polling Support
// Handles URL submissions and polls for extraction results

response = Map();

// Helper function to generate HMAC signature
function generateSignature(body, secret)
{
	return encodeHMAC(body, secret, "SHA256");
}

// Helper function to poll job results
function pollJobResult(jobId, secret, maxRetries = 30)
{
	baseUrl = "https://cliq-webpage-analyser.onrender.com";
	
	for(i = 0; i < maxRetries; i++)
	{
		try
		{
			// Generate signature for GET request
			// For GET requests with no body, sign empty string
			signature = generateSignature("", secret);
			
			headers = Map();
			headers.put("x-cliq-signature", signature);
			
			// Poll for result
			result = invokeurl
			[
				url: baseUrl + "/result/" + jobId
				type: GET
				headers: headers
			];
			
			status = result.get("status");
			info "Poll #" + (i + 1) + " - Status: " + status;
			
			if(status == "done")
			{
				return result.get("summary");
			}
			else if(status == "failed")
			{
				return null; // Job failed
			}
			
			// Wait before next poll (exponential backoff)
			delay = (i + 1) * 500; // 500ms, 1s, 1.5s, etc.
			if(delay > 5000)
			{
				delay = 5000; // Cap at 5 seconds
			}
			
			// Deluge sleep (in milliseconds)
			// Note: Use task scheduling instead for production
		}
		catch (e)
		{
			info "Poll error: " + e.getMessage();
		}
	}
	
	return null; // Timeout after max retries
}

// Main handler logic
if(message.startsWith("http://") || message.startsWith("https://"))
{
	try
	{
		info "Processing URL: " + message;
		
		// Step 1: Prepare request
		reqBody = Map();
		reqBody.put("url", message);
		jsonBody = reqBody.toString();
		
		// Get secret (use Zoho Vault in production)
		hmacSecret = "1001.3ea9d992cfa4a3e0db5f5c83fb5a7710.b2631f1a4a9275a484f44c14afbf88e5";
		
		// Step 2: Generate signature
		signature = generateSignature(jsonBody, hmacSecret);
		info "Generated signature: " + signature.substring(0, 20) + "...";
		
		// Step 3: Send request with signature
		headers = Map();
		headers.put("Content-Type", "application/json");
		headers.put("x-cliq-signature", signature);
		
		apiResponse = invokeurl
		[
			url: "https://cliq-webpage-analyser.onrender.com/analyze"
			type: POST
			parameters: reqBody
			headers: headers
		];
		
		info "API Response: " + apiResponse.toString();
		
		// Step 4: Handle response
		if(apiResponse.get("ok") == true && apiResponse.get("status") == "queued")
		{
			jobId = apiResponse.get("jobId");
			
			response.put("text", 
				"‚úÖ Job submitted successfully!\n\n" +
				"*Job ID:* `" + jobId + "`\n" +
				"*Status:* Queued\n\n" +
				"*Polling for results...* ‚è≥"
			);
			
			// Step 5: Poll for results (optional - for faster user experience)
			// Note: In production, use task scheduling to poll asynchronously
			// For now, return job ID and let user check status manually
			
			response.put("suggestions", {
				"list": {
					{"text": "üìä Check Status"},
					{"text": "‚ùå Cancel Job"}
				}
			});
		}
		else
		{
			errorMsg = apiResponse.get("error");
			response.put("text", "‚ùå Error: " + (errorMsg != null ? errorMsg : "Unknown error"));
			info "Request failed: " + errorMsg;
		}
	}
	catch (e)
	{
		info "Exception caught: " + e.getMessage();
		response.put("text", "‚ùå Error processing request: " + e.getMessage());
	}
}
else if(message.containsIgnoreCase("status") && context != null && context.containsKey("jobId"))
{
	// Check status of existing job
	try
	{
		jobId = context.get("jobId");
		hmacSecret = "1001.3ea9d992cfa4a3e0db5f5c83fb5a7710.b2631f1a4a9275a484f44c14afbf88e5";
		
		signature = generateSignature("", hmacSecret);
		
		headers = Map();
		headers.put("x-cliq-signature", signature);
		
		result = invokeurl
		[
			url: "https://cliq-webpage-analyser.onrender.com/result/" + jobId
			type: GET
			headers: headers
		];
		
		status = result.get("status");
		
		if(status == "done")
		{
			summary = result.get("summary");
			components = summary.get("components");
			componentCount = summary.get("componentCount");
			
			response.put("text",
				"‚úÖ *Extraction Complete!*\n\n" +
				"*Components Found:* " + componentCount + "\n" +
				"*URL:* " + summary.get("url") + "\n\n" +
				"*Output Files:*\n" +
				"‚Ä¢ `components.json` - Component metadata\n" +
				"‚Ä¢ `styles.css` - CSS rules\n" +
				"‚Ä¢ `Components.jsx` - React code\n" +
				"‚Ä¢ `preview.html` - HTML preview"
			);
		}
		else if(status == "processing")
		{
			response.put("text", "‚è≥ Still processing... Please wait!");
		}
		else if(status == "failed")
		{
			response.put("text", "‚ùå Job failed: " + result.get("error"));
		}
		else
		{
			response.put("text", "üìã Status: " + status);
		}
	}
	catch (e)
	{
		response.put("text", "‚ùå Error checking status: " + e.getMessage());
	}
}
else if(message.containsIgnoreCase("HI") || message.containsIgnoreCase("HEY"))
{
	text = "Hi! How you doing'? :wink:\n\nYou can:\n‚Ä¢ Send me a **URL** and I'll extract UI components\n‚Ä¢ Ask for **Status** to check extraction progress";
	response.put("suggestions", {
		"list": {
			{"text": "I am great!"},
			{"text": "Meh!"}
		}
	});
	response.put("text", text);
}
else if(message.equals("I am great!"))
{
	text = "Glad to hear that! :smile: Send me a URL to analyze!";
	response.put("text", text);
}
else if(message.equals("Meh!"))
{
	text = "Oops! Don't you worry. Your day is definitely going to get better. :grinning:";
	response.put("text", text);
}
else
{
	text = "Send me a URL (starting with http:// or https://) and I'll extract UI components for you! :rocket:";
	response.put("text", text);
}

return response;
